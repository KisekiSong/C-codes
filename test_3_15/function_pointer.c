#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//int Add(int x, int y)
//{
//    return x + y;
//}
//int main()
//{
//    //int (*pf)(int, int) = &Add;
//    ////先用()和*号，确保pf是一个指针
//    ////在确定函数的形参类型，写在括号里：(int, int)
//    ////最后看函数的返回值，返回值为int，最前面写int
//    ////指针pf的类型为：int(*)(int, int)(变量去掉名字就是类型)
//    ////pf就是函数指针，即指向函数的指针
//    ////调用函数：
//    //int ret1 = (*pf)(4, 5);
//    //printf("%d\n", ret1);
//    ////输出为9
//    ////pf为指针，*pf为解引用，即调用了pf指向的函数
//    //int ret2 = pf(4, 5);
//    //printf("%d\n", ret2);
//
//    //int ret3 = Add(4, 5);
//    //printf("%d\n", ret3);
//
//    (*(void(*)())0 )();
//    //void是函数类型
//    //0是传入的参数？
//    //*(void(*)())是函数指针类型，函数返回类型为void，且不需要传入参数
//    //(类型)常量 = 强制类型转换
//    //把 0 强制转换为函数指针类型
//    //把 0 当作函数的地址来看
//    //调用0地址处放的那个函数，是一次函数调用
//    //0地址处放的这个函数是没有参数，返回类型是void
//
//    void (*signal(int, void(*)(int)))(int);
//    //分析：
//    //分析解引用操作：
//    //signal(int, void(*)(int))这是一个函数，因为先和后面的()结合，表示函数
//    //函数传入参数为int和void(*)(int)函数指针类型
//    //函数名，函数参数类型都有了，剩下的就是函数返回类型
//    //返回类型是void(*)(int)
//    //但是写法上比较怪异，signal(int, void(*)(int))被放在了*后面
//    //所以整体是一个函数的声明
//    //函数名：signal
//    //传参类型：int, void(*)(int)
//    //返回类型：void(*)(int)--->函数指针
//
//
//    return 0;
//}