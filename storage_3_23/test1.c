#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//写一个程序检测存储是大端还是小端
int check_sys()
{
	int a = 1;
	return *(char*)&a;
	//存储的时候是从低地址向高地址存放，只是谁放在低地址的问题
	//小端是数据的低位放在低地址，大端是数据的高位放在低地址
	//如果我们取a的地址，默认拿到低地址，然后将其转换为char类型，只有一个字节
	//解引用后的结果如果为1，说明低位存储在了低地址；如果是0，说明高位存在了低地址
}

int main()
{

	//if (check_sys())
	//{
	//	printf("小端\n");
	//}
	//else
	//	printf("大端\n");
	// 
	//int a[4] = { 1,2,3,4 };
	//int* ptr1 = (int*)(&a + 1);
	////&a取到的是数组的地址，加1跳过整个数组
	//int* ptr2 = (int*)((int)a + 1);
	////(int)a之后，地址变成了int，+1就真的只是+1，在地址上前进1个字节
	////01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00
	////|a[0] = 1   |a[1] = 2   | a[2] = 3  | a[4] = 4
	////移动一个字节之后，读取的内容变成了: 00 00 00 02
	////由于是小端存储，高位存储在高地址，所以读取到的数字是：
	//// 2000000

	//printf("%x, %x", ptr1[-1], *ptr2);
	////4, 2000000

	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);
	//n是有符号整型，内存中存放的二进制码为：
	//00000000000000000000000000001001
	//在浮点数看来，第一位为S，S后面为E，E后面为M
	//此时S=0，E全为0，这时属于Denormalized number的情况
	//此时E的真实值E=1-127，M的值为0.00000000000000000001001(此时规定个位为0)
	//所以在浮点数看来，整型9实际上是：0.00000000000000000001001*2^(-126)
	//非常接近0
	//虽然内存中，存放的二进制代码相同，但是不同的解读方式会带来截然不同的结果

	*pFloat = 9.0;
	printf("num的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);
	//二进制数：1001.0 = 1.001*2^3
	//存放时，S=0, E=3+127=130, M = 00100000000000000000000
	//内存中存放的值为：0 10000010 00100000000000000000000
	//                 s=0 E=128+2  M按照二进制下小数位数排列


	return 0;
}